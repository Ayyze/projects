input {
  beats {
    port => 5044
    ssl => true
    ssl_certificate_authorities => ["/etc/logstash/certs/http_ca.crt"]
    ssl_certificate => "/etc/logstash/certs/logstash.crt"
    ssl_key => "/etc/logstash/certs/logstash.key"
    ssl_verify_mode => "force_peer"
  }
}
filter {
  if [event][module] == "apache" {
    if [fileset][name] == "access" {
      grok {
        match => { "message" => ["%{IPORHOST:[source][address]} - %{DATA:[user][name]} \[%{HTTPDATE:[apache][access][time]}\] \"(?:%{WORD:[http][request][method]} %{DATA:[url][original]} HTTP/%{NUMBER:[http][version]}|-)?\" %{NUMBER:[http][response][status_code]} (?:%{NUMBER:[http][response][body][bytes]}|-)( \"%{DATA:[http][request][referrer]}\")?( \"%{DATA:[user_agent][original]}\")?",
        "%{IPORHOST:[source][address]} - %{DATA:[user][name]} \\[%{HTTPDATE:[apache][access][time]}\\] \"-\" %{NUMBER:[http][response][status_code]} -",
        "\\[%{HTTPDATE:[apache][access][time]}\\] %{IPORHOST:[source][address]} %{DATA:[apache][access][ssl][protocol]} %{DATA:[apache][access][ssl][cipher]} \"%{WORD:[http][request][method} %{DATA:[url][original]} HTTP/%{NUMBER:[http][version]}\" %{NUMBER:[http][response][body][bytes]}"
        ] }
        remove_field => "message"
      }
      grok {
        match => { "[source][address]" => ["^(%{IP:[source][ip]}|%{HOSTNAME:[source][domain]})$"]}
      }
      mutate {
        rename => { "[event][created]" => "@timestamp" }
      }
      date {
        match => [ "[apache][access][time]", "dd/MMM/yyyy:H:m:s Z" ]
        remove_field => "[apache][access][time]"
      }
      useragent {
        source => "[user_agent][original]"
      }
      geoip {
        source => "[source][ip]"
        target => "[source][geo]"
      }
    }
    else if [fileset][name] == "error" {
      grok {
        match => {"message" => ["\[%{APACHE_TIME:[apache][error][timestamp]}\] \[%{LOGLEVEL:[log][level]}\] ( \[client %{IPORHOST:[source][address]}(:%{POSINT:[source][port]})?\])? %{GREEDYDATA:[message]}",
            "\[%{APACHE_TIME:[apache][error][timestamp]}\] \[%{DATA:[apache][error][module]}:%{LOGLEVEL:[log][level]}\] \[pid %{NUMBER:[process][pid]}(:tid %{NUMBER:[process][thread][id]})?\] ( \[client %{IPORHOST:[source][address]}(:%{POSINT:[source][port]})?\])? %{GREEDYDATA:[message]}"
        ]}
        pattern_definitions => {
          "APACHE_TIME" => "%{DAY} %{MONTH} %{MONTHDAY} %{TIME} %{YEAR}"
        }
        remove_field => "message"
      }
      date {
        match => [ "[apache][error][timestamp]", "EEE MMM dd H:m:s YYYY", "EEE MMM dd H:m:s.SSSSSS YYYY" ]
        remove_field => "[apache][error][timestamp]"
      }
      grok {
        match => { "[source][address]" => ["^(%{IP:[source][ip]}|%{HOSTNAME:[source][domain]})$"]}
      }
      geoip {
        source => "[source][ip]"
        target => "[source][geo]"
      }
    }
  }
  date {
    match => ["timestamp", "MMM dd HH:mm:ss"]
  }
  if [fields][event_type] == "cowrie" {
      json {
          source => message
          target => honeypot
      }

      date {
          match => [ "timestamp", "ISO8601" ]
      }

      if [src_ip]  {

          mutate {
              add_field => { "src_host" => "%{src_ip}" }
          }

          dns {
              reverse => [ "src_host" ]
              nameserver => [ "8.8.8.8", "8.8.4.4" ]
              action => "replace"
              hit_cache_size => 4096
              hit_cache_ttl => 900
              failed_cache_size => 512
              failed_cache_ttl => 900
          }


          geoip {
              source => "src_ip"
              target => "geoip"
              database => "/usr/share/logstash/data/geoip_database_management/1713361456/GeoLite2-City.mmdb"
          }

      }

      mutate {
          # cut out useless tags/fields
          remove_tag => [ "beats_input_codec_plain_applied"]
          remove_field => [ "[log][file][path]", "[log][offset]" ]
      }
  }
}
output {
  if [@metadata][pipeline] {
        elasticsearch {
        ssl => true
        hosts => ["https://<IP Address>:9200"]
        cacert => "/etc/logstash/certs/http_ca.crt"
        user => "logstash_internal"
        password => "<password>"
        manage_template => false
        index => "%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM.dd}"
        pipeline => "%{[@metadata][pipeline]}"
        }
  } else if [fields][event_type] == "cowrie" {
      elasticsearch {
          hosts => ["https://<IP Address>:9200"]
          ssl => true
          cacert => "/etc/logstash/certs/http_ca.crt"
          user => "elastic"
          password => "<password>"
          index => "cowrie-logstash-%{+YYYY.MM.dd}"
          ilm_enabled => auto
          ilm_rollover_alias => "cowrie-logstash"
      }
      file {
          path => "/tmp/cowrie-logstash.log"
          codec => json
      }
      stdout {
          codec => rubydebug
      } 
  } else {
        elasticsearch {
        ssl => true
        hosts => ["https://<IP Address>:9200"]
        cacert => "/etc/logstash/certs/http_ca.crt"
        user => "logstash_internal"
        password => "<password>"
        manage_template => false
        index => "%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM.dd}"
        }
  }
}
